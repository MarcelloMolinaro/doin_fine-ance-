from dagster import Definitions, asset, Config, AssetExecutionContext
import pandas as pd
from sqlalchemy import create_engine, text
from pydantic import Field
from pathlib import Path
from extractors.weather_api import weather_source
from extractors.simplefin_api import simplefin_financial_data
from classifier_train import train_transaction_classifier
from classifier_predict import predict_transaction_categories

# Dagster-dbt integration
USE_DBT_ASSETS = False
all_dbt_assets = None
dbt_resource = None

try:
    from dagster_dbt import DbtCliResource, dbt_assets
    import json
    
    # Path to dbt manifest.json (generated by dbt compile)
    DBT_PROJECT_DIR = Path("/opt/dbt")
    DBT_MANIFEST_PATH = DBT_PROJECT_DIR / "target" / "manifest.json"
    
    # Create DbtCliResource
    dbt_resource = DbtCliResource(
        project_dir=DBT_PROJECT_DIR,
        profiles_dir=DBT_PROJECT_DIR,
    )
    
    # Load all dbt models as Dagster assets if manifest exists
    if DBT_MANIFEST_PATH.exists():
        # Load manifest manually
        with open(DBT_MANIFEST_PATH) as f:
            manifest = json.load(f)
        
        # Config class for dbt assets
        class DbtAssetsConfig(Config):
            """Configuration for dbt assets."""
            full_refresh: bool = Field(
                default=False,
                description="If True, run dbt with --full-refresh flag (useful for incremental models)"
            )
        
        @dbt_assets(manifest=manifest)
        def all_dbt_assets(
            context: AssetExecutionContext, 
            dbt: DbtCliResource,
            config: DbtAssetsConfig
        ):
            """All dbt models loaded as Dagster assets.
            
            Uses 'dbt run' to build models. To run with --full-refresh on 
            a specific incremental model, use the Dagster UI config or CLI.
            
            In the UI: Select the asset → Materialize → Config → Add:
            {"full_refresh": true}
            
            Or use CLI:
            dagster asset materialize --select <model_name> -c '{"full_refresh": true}'
            """
            # Build dbt command
            dbt_cmd = ["run"]
            
            # If full_refresh is set, add the flag
            if config.full_refresh:
                dbt_cmd.append("--full-refresh")
                context.log.info("Running dbt with --full-refresh flag")
            
            yield from dbt.cli(dbt_cmd, context=context).stream()
        
        USE_DBT_ASSETS = True
    else:
        # Manifest doesn't exist yet - user needs to run dbt compile first
        print("⚠️  dbt manifest.json not found. Run 'dbt compile --project-dir /opt/dbt' to generate it.")
        
except ImportError:
    # dagster-dbt not installed - skip integration
    print("⚠️  dagster-dbt not installed. Install with: pip install dagster-dbt")
except Exception as e:
    # Other errors (e.g., file read issues) - skip integration
    print(f"⚠️  Error setting up dagster-dbt integration: {e}")

@asset 
def load_to_postgres(context, simplefin_financial_data): # source1, source2, source3, weather_source, 
    engine = create_engine('postgresql+psycopg2://dagster:dagster@postgres:5432/dagster')
    simplefin_financial_data.to_sql('simplefin', engine, schema='public', if_exists='append', index=False, method='multi')
    engine.dispose()
    context.log.info("Loaded all sources into Postgres.")

@asset
def run_dbt(context, load_to_postgres):
    import subprocess
    import os

    os.environ["DBT_PROFILES_DIR"] = "/opt/dbt"
    
    # First run dbt seed
    seed_result = subprocess.run(
        ["dbt", "seed", "--project-dir", "/opt/dbt"], 
        cwd="/opt/dagster/app",
        capture_output=True,
        text=True
    )
    context.log.info(seed_result.stdout)
    context.log.info(seed_result.stderr)

    # Then run dbt run
    result = subprocess.run(
        ["dbt", "run", "--project-dir", "/opt/dbt"], 
        cwd="/opt/dagster/app",
        capture_output=True,
        text=True
    )
    context.log.info(result.stdout)
    context.log.info(result.stderr)

    if result.returncode != 0:
        raise Exception("dbt run failed")
    context.log.info("dbt transformations complete.")


@asset
def run_dbt_test(context, run_dbt):
    """Run dbt tests to validate data quality."""
    import subprocess
    import os

    os.environ["DBT_PROFILES_DIR"] = "/opt/dbt"
    
    # Run dbt test
    result = subprocess.run(
        ["dbt", "test", "--project-dir", "/opt/dbt"], 
        cwd="/opt/dagster/app",
        capture_output=True,
        text=True
    )
    context.log.info(result.stdout)
    if result.stderr:
        context.log.warning(result.stderr)
    
    if result.returncode != 0:
        raise Exception(f"dbt test failed: {result.stderr}")
    context.log.info("dbt tests passed.")


class FctValidatedTrxnsConfig(Config):
    full_refresh: bool = Field(
        default=False,
        description="If True, run dbt with --full-refresh flag"
    )


@asset
def run_fct_validated_trxns(context: AssetExecutionContext, config: FctValidatedTrxnsConfig):
    """Run only the fct_validated_trxns dbt model."""
    import subprocess
    import os

    os.environ["DBT_PROFILES_DIR"] = "/opt/dbt"
    
    # Build dbt command
    cmd = ["dbt", "run", "--project-dir", "/opt/dbt", "--select", "fct_validated_trxns"]
    
    if config.full_refresh:
        cmd.append("--full-refresh")
        context.log.info("Running fct_validated_trxns with --full-refresh")
    else:
        context.log.info("Running fct_validated_trxns (incremental)")
    
    result = subprocess.run(
        cmd,
        cwd="/opt/dagster/app",
        capture_output=True,
        text=True
    )
    
    context.log.info(result.stdout)
    if result.stderr:
        context.log.warning(result.stderr)
    
    if result.returncode != 0:
        raise Exception(f"dbt run failed for fct_validated_trxns: {result.stderr}")
    
    context.log.info("fct_validated_trxns model run complete.")

# disable testing assets for now [source1, source2, source3, weather_source,]
all_assets = [
    simplefin_financial_data, 
    load_to_postgres, 
    run_dbt,  # Keep this for now as a fallback, or remove if using all_dbt_assets
    run_dbt_test,  # Run dbt tests after models are built
    run_fct_validated_trxns,
    train_transaction_classifier,
    predict_transaction_categories
]

# Add dbt assets if available
if USE_DBT_ASSETS and all_dbt_assets:
    all_assets.append(all_dbt_assets)

# Build resources dict (only if dbt_resource is available)
resources = {}
if dbt_resource:
    resources["dbt"] = dbt_resource

definitions = Definitions(
    assets=all_assets,
    resources=resources if resources else None
)